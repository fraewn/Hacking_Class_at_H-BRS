from Crypto.Cipher import AES

# strat
# 0. get a ciphertext via input as long as the one resulting from the flag
# 1. formatierung alles in bytes
# 2. nonce reuse schwachstelle: wir haben zwei ciphertexte die mit der selben nonce generiert wurden:
# xor both ciphertexts
# wir wissen das im plaintext der flag "flag" vorkommt und wir wissen ja was wir in unseren eingeben haben
# 1. xor both ciphertexts to get the decrypted versions of them (they still need to be xored)
# 2. es ist egal, dass es iwie mehrere bl√∂cke etc. gibt, dadurch dass flag und input genau gleich lang sind wurde genau dasselbe gemacht
# 3. weil die mit genau dem selben key hergestellt wurden gilt: xor(flag_encr, input_encry) = xor(flag_plain, input_plain)
# 4. wenn ich jetzt das ergebnis von dem was ich herstellen kann (das linke xor) mit dem plain was ich hab (input_plain) xore, bekomme ich flag_plain

def xor(a, b):
    res = bytearray()
    for i in range(len(a)):
        # xor string a at character i with string b at character i
        res.append(a[i] ^ b[i])
    return bytes(res)

# creates an output same length as flag encr.
input = "A" * 33
print(input)

flag_encr_hex = '41ed2567dbed155357ed846a689e63c3f00348c4db6b1fc48cb0b2670d62878120'
flag_encr_bytes = bytes.fromhex(flag_encr_hex)
print(flag_encr_bytes)

input_encr_hex = '66c00541e1e2647c75c99a594caa51e7ee2b7adaeb5f37f1a8ae914f3857a3b21c'
input_encr_bytes = bytes.fromhex(input_encr_hex)
print(input_encr_bytes)

# 1. eliminate key stream
xored = xor(flag_encr_bytes, input_encr_bytes)
print("xor(flag_encr, input_enrc):")
print(xored)



# 2. xor plaintext with elimination to get flag
print(xor(xored, input.encode()))


print("test if xor(flag_encr, input_enrc) is the same as xor(flag_plain, input_plain). here is the latter:")
flag = 'flag{N0nce_reuse_is_quite_bitter}'

xored_plain_texts = xor(input.encode(), flag.encode())
print(xored_plain_texts)
print("they are the same")


#flag = xor(key,flag_encr_bytes)
#print(flag.decode())

#aes = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)
#decrypted_flag = aes.decrypt(flag_bytes)





