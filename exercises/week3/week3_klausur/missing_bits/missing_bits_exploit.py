from Crypto.Cipher import AES

# strategy
# 1. get IV
# 2. convert to bytes
# 3. brute force last 4 bytes of key

output_hex = "05ef9caa70722673e46d8fddc560ad04d225c8eb82b9bafe0a13e7f9f2e12f493f82c74d5ffdffb81e6021e3da818ec3"

# 28 chars, 4 chars are missing --> 2 bytes brauche ich noch
key_hex = '797a05c26d83f0579780252f147a'
iv_hex = '05ef9caa70722673e46d8fddc560ad04'
flag_hex = 'd225c8eb82b9bafe0a13e7f9f2e12f493f82c74d5ffdffb81e6021e3da818ec3'

# 2. convert to bytes
key_bytes = bytes.fromhex(key_hex)
print(key_bytes)
key_bytes = bytearray(key_bytes)
print(key_bytes)

iv_bytes = bytes.fromhex(iv_hex)
flag_bytes = bytes.fromhex(flag_hex)

# 3. brute force rest of key
for byte_15 in range(0,255):
    for byte_16 in range(0,255):
        key_bytes.append(byte_15)
        key_bytes.append(byte_16)
        # try decrypt
        aes = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)
        decrypted_flag = aes.decrypt(flag_bytes)
        try:
            if decrypted_flag.decode().__contains__('flag'):
                print(decrypted_flag.decode())
        except:
            # just something not mattering here
            a = 3
        # dann die beiden ausprobierten bytes am Ende wieder weg machen (sonst wird der key ja immer l√§nger)
        # ich appende die ja beide in der schleife hier, daher muss ich die auch beide in der schleife poppen
        key_bytes.pop()
        key_bytes.pop()


