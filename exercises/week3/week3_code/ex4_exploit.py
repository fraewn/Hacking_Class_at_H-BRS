from Crypto.Cipher import AES

part_key_hex = '797a05c26d83f0579780252f147a'
part_key = bytes.fromhex(part_key_hex)
print(part_key) # b'yz\x05\xc2m\x83\xf0W\x97\x80%/\x14z'

iv_hex = '05ef9caa70722673e46d8fddc560ad04'
iv_ba = bytes.fromhex(iv_hex)
print(iv_ba) # b'\x05\xef\x9c\xaapr&s\xe4m\x8f\xdd\xc5`\xad\x04'

fl_hex = 'd225c8eb82b9bafe0a13e7f9f2e12f493f82c74d5ffdffb81e6021e3da818ec3'
fl_ba = bytes.fromhex(fl_hex)
print(fl_ba) # b'\xd2%\xc8\xeb\x82\xb9\xba\xfe\n\x13\xe7\xf9\xf2\xe1/I?\x82\xc7M_\xfd\xff\xb8\x1e`!\xe3\xda\x81\x8e\xc3'

part_key_ba = bytearray(part_key)
for i in range (0,0xff):
    for j in range (0, 0xff):
        key = part_key_ba
        key.append(i)
        key.append(j)
        # jetzt hab ich einen key
        aes = AES.new(key, AES.MODE_CBC, iv_ba)
        decrypted_flag = aes.decrypt(fl_ba)
        try:
            if(decrypted_flag.decode().startswith("flag")):
                print(decrypted_flag.decode())
        except:
            a = 3
        # dann die beiden ausprobierten bytes am Ende wieder weg machen (sonst wird der key ja immer l√§nger)
        key.pop()
        key.pop()





