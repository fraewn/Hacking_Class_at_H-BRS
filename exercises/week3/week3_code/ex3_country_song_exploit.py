from Crypto.Cipher import AES
from Crypto.Util import Padding
from multiprocessing import Process, Queue

steps = 16777216  # FFFFFF


def setCoreSteps(numCores):
    coreSteps = 0
    coreSteps = int(steps / numCores / 2)
    return coreSteps


def stage1(coreID, coreSteps, key2, pngheader, iv, q):
    # wir erstellen die Tabelle (ein dictionary wo wir später für jeden erstellte encrypteten text unseren benutzen key2 rein tun)
    candHinrunde = {}

    start = coreID * coreSteps
    end = start + (coreSteps - 1)
    # bruteKey ist die Variable die immer an die keys daran gehängt, wird (also 3 bytes bzw. 6 Zeichen in hex), um alle Variations auszuprobieren
    # die macht das alles in hex
    bruteKey = hex(start)[2:]

    while len(bruteKey) < 6:
        bruteKey = "0" + bruteKey

    for i in range(start, end):
        # ein temp. key wird erstellt indem wir den brutekey and key2 dran hängen
        # alles noch in hex
        keyTemp = key2 + bruteKey

        # wir wandeln den temporären key in bytes um
        keyBytes = bytes.fromhex(keyTemp)
        # wir erstellen ne neue Verschlüsselung mit keyBytes (also temp. key in bytes) und dem iv, den wir kennen
        pre = AES.new(keyBytes, AES.MODE_CBC, iv)

        # wir entcrypten den plaintext (also den uns bekannten png header)mit unserer neuen verschlüsselung
        cipher = pre.encrypt(pngheader)
        # wir speichern das encryptete und den dafür genutzten key in der Tabelle (dem dict)
        candHinrunde[cipher] = keyBytes

        # wir setzen den brute key zurück oder so
        bruteKey = int(bruteKey, 16)
        bruteKey = bruteKey + 1
        bruteKey = hex(bruteKey)[2:]
        while len(bruteKey) < 6:
            bruteKey = "0" + bruteKey

    print("try to write into queue")
    q.put(candHinrunde)
    print("wrote into queue")
    return


def stage2(coreID, coreSteps, key2, cipher, iv, pl_list, cipherALL):
    start = coreID * coreSteps
    end = start + (coreSteps - 1)
    bruteKey = hex(start)[2:]

    while len(bruteKey) < 6:
        bruteKey = "0" + bruteKey

    for i in range(start, end):
        keyTemp = key2 + bruteKey

        keyBytes = bytes.fromhex(keyTemp)
        pre = AES.new(keyBytes, AES.MODE_CBC, iv)

        text = pre.decrypt(cipher)

        if text in pl_list:
            keyOne = keyBytes
            keyTwo = pl_list[text]
            print("k1 :" + keyOne.hex() + "\nk2: " + keyTwo.hex())
            decrypt(cipherALL, keyOne, keyTwo, iv)

        bruteKey = int(bruteKey, 16)
        bruteKey = bruteKey + 1
        bruteKey = hex(bruteKey)[2:]
        while len(bruteKey) < 6:
            bruteKey = "0" + bruteKey


def decrypt(cipher, k1, k2, iv):
    aes1 = AES.new(k1, AES.MODE_CBC, iv)
    aes2 = AES.new(k2, AES.MODE_CBC, iv)

    plain = aes2.decrypt(aes1.decrypt(cipher))

    file = open("test.png", "wb")
    file.write(plain)
    file.close


def main():
    # das ist die gegebene file wo das encryptete bild drin ist und die beiden keys
    cipher = open("output.txt", "r").read()
    # wir definieren den png-header hier
    pngheader = '89504e470d0a1a0a' + '0000000d' + '49484452'
    # und konvertieren in von hex zu bytes
    pngheader = bytes.fromhex(pngheader)

    # wir kennen die keys
    # wir lesen die output.txt aus, sodass wir key 1 kriegen
    key1 = cipher[len(cipher) - 54:len(cipher) - 28]
    # wir lesen die output.tx aus, sodass wir key2 kriegen
    key2 = cipher[len(cipher) - 27:len(cipher) - 1]
    # wir wissen iv ist 16 bytes lang, also 32 zeichen in hex
    # und steht ganz am Anfang
    iv = cipher[0:32]
    iv = bytes.fromhex(iv)

    # dann holen wir uns die cipher, die am Anfang beginnt (mit dem IV)
    cipher = cipher[:len(cipher) - 55]
    # in cipherALL speichern wir nur den doppelt encrypteten text, ohne den IV
    cipherALL = cipher[32:]
    # wir wandeln cipherALL in bytes um (also müsste es dann nur noch halb so lang sein)
    cipherALL = bytes.fromhex(cipherALL)

    # dann speichern wir in cipher alles aus der cipher von zeichen 32 bis zeichen 64
    # der png header hat 16 bytes, also 32 zeichen in hex
    # also den png header, der direkt nach dem IV kommen sollte
    cipher = cipher[32:64]
    # wir wandeln den header von hex nach bytes um
    cipher = bytes.fromhex(cipher)

    # Wir verwenden paralleliserung damit es schneller geht
    cores = 8
    coreSteps = setCoreSteps(cores)

    ps = []
    q = Queue()
    setCoreSteps(cores)

    print("Hinrunde")
    # for i in 8 (also für jeden Kern)
    for i in range(cores):
        # ruf den Prozess auf und schreibe das Ergebnis in ps (nehm ich an)
        ps.append(Process(target=stage1, args=(i, coreSteps, key2, pngheader, iv, q)))

    for p in ps:
        p.start()

    pl = {}

    for p in ps:
        pl.update(q.get())

    for p in ps:
        p.join()

    ps = []

    print("Rückrunde")

    for i in range(cores):
        ps.append(Process(target=stage2, args=(i, coreSteps, key1, cipher, iv, pl, cipherALL)))

    for p in ps:
        p.start()

    for p in ps:
        p.join()


if __name__ == "__main__":
    main()
