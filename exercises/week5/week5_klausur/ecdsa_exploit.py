from pwn import *
from hashlib import sha1
from ecdsa import SigningKey, SECP256k1
from gmpy import invert, mpz

# get token 1
conn = remote("vuln.redrocket.club", 9998)
conn.recvuntil("name:")
m1 = "AAAA"
conn.sendline(m1)

first_token = conn.recvline()
first_token = first_token[12 + len(m1):].rstrip()

conn.close()

# get token 2
conn = remote("vuln.redrocket.club", 9998)
conn.recvuntil("name:")
m2 = "BBBB"
conn.sendline(m2)

secon_token = conn.recvline()
secon_token = secon_token[12 + len(m2):].rstrip()

print(first_token)
print(secon_token)

# get r and s
r = first_token[:64]
s1 = first_token[64:]
s2 = secon_token[64:]

print(r)
print(s1)
print(s2)

# recover private key
# curve = secp256k1
n = SECP256k1.order

r = int(r,16)
s1 = int(s1, 16)
s2 = int(s2, 16)

z1 = int(sha1(m1.encode()).hexdigest(), 16)
z2 = int(sha1(m2.encode()).hexdigest(), 16)

# calc k
# (z1-z2)/(s1-s2) or multiplicate with inverse of (s1-s2), then result mod n
k = (((z1 - z2) % n) * invert(s1 - s2, n)) % n

private_key = (((s1 * k - z1)) * invert(mpz(r), n)) % n

print(private_key)

# sign user token "admin"
sk = SigningKey.from_secret_exponent(curve=SECP256k1, hashfunc=sha1, secexp=private_key)
sig = sk.sign(data="admin".encode(), k=k)

print(sig.hex())

conn.sendline("admin," + str(sig.hex()))
conn.interactive()









