from ecdsa.curves import SECP256k1
from ecdsa import SigningKey
from hashlib import sha1
from ecdsa.numbertheory import inverse_mod

n = SECP256k1.order

r1 = int('0589abade28762eea832854f89f6f144e4ef8ba27c03026f38eac070349b98a1', 16)
s1 = int('4fd569a35deea668c3cf758048a281297e0c48851c8306f90ed84d35fa0a143f', 16)
m1 = '8'
z1 = int(sha1(m1.encode('utf-8')).hexdigest(), 16)

r2 = int('0589abade28762eea832854f89f6f144e4ef8ba27c03026f38eac070349b98a1', 16)
s2 = int('698363e6fb3c744571e95ead78e269b0f4deba0e43b8faf9842c6eed261185a5', 16)
m2 = '9'
z2 = int(sha1(m2.encode('utf-8')).hexdigest(), 16)

# Calculate k
k = (((z1 - z2) % n) * inverse_mod(s1 - s2, n)) % n
print("k: 0x{:x}".format(k))

# Calculate private key
private_key = ((((s1 * k) % n) - z1) * inverse_mod(r1, n)) % n
print("private key: 0x{:x}".format(private_key))

# create admin signature
sk = SigningKey.from_secret_exponent(private_key,curve=SECP256k1)
admin_enc = "admin".encode()
sig = sk.sign(admin_enc,k=k)
print(str(sig.hex()))